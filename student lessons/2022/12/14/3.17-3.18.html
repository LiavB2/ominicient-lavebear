<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">3.17 - 3.18 Undecidability and Algorithmic Efficiency Notes and Hacks</h1><p class="page-description">Markdown post of the group lesson for 3.17-3.18</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-12-14T00:00:00-06:00" itemprop="datePublished">
        Dec 14, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      3 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/ominicient-lavebear/categories/#Student Lessons">Student Lessons</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#notes">Notes</a>
<ul>
<li class="toc-entry toc-h2"><a href="#unsolvable-vs-undecidable">Unsolvable vs undecidable</a></li>
<li class="toc-entry toc-h2"><a href="#undecidability-example">Undecidability Example</a></li>
<li class="toc-entry toc-h2"><a href="#vocab">Vocab</a>
<ul>
<li class="toc-entry toc-h3"><a href="#collatz-conjecture">Collatz Conjecture</a></li>
<li class="toc-entry toc-h3"><a href="#hailstone-numbers">Hailstone numbers</a></li>
<li class="toc-entry toc-h3"><a href="#undecidable-problems">Undecidable problems</a></li>
<li class="toc-entry toc-h3"><a href="#iteration">Iteration</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#hailstone-numbers-code-example">Hailstone Numbers Code Example</a></li>
<li class="toc-entry toc-h2"><a href="#algorithm-efficiency">Algorithm Efficiency</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#hacks">Hacks</a>
<ul>
<li class="toc-entry toc-h2"><a href="#combine-hailstone-and-number-of-iterations">Combine Hailstone and Number of Iterations</a></li>
<li class="toc-entry toc-h2"><a href="#write-one-algorithm-that-is-efficient-and-one-that-is-inefficient-compare-them-and-explain-why-one-is-and-why-one-isnt-efficient">Write one algorithm that is efficient and one that is inefficient. Compare them and explain why one is and why one isn’t efficient.</a></li>
<li class="toc-entry toc-h2"><a href="#how-one-algorithm-can-be-more-efficient-than-annother-using-mathematical-and-formal-reasoning">How one algorithm can be more efficient than annother using mathematical and formal reasoning</a></li>
<li class="toc-entry toc-h2"><a href="#use-variables-if-statements-and-loops-to-program-an-algorithm">Use variables, if statements, and loops to program an algorithm</a></li>
</ul>
</li>
</ul><h1 id="notes">
<a class="anchor" href="#notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notes</h1>

<h2 id="unsolvable-vs-undecidable">
<a class="anchor" href="#unsolvable-vs-undecidable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unsolvable vs undecidable</h2>
<ul>
  <li>Unsolvable: is that no algorithm can be written to get the answer to it</li>
  <li>Undecidable: There is no code that can find the answer, because it is too complext, but there is an answer.</li>
</ul>

<h2 id="undecidability-example">
<a class="anchor" href="#undecidability-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Undecidability Example</h2>

<p><img src="/ominicient-lavebear/images/yasha1.png" alt="" title="https://github.com/LiavB2/ominicient-lavebear"></p>

<ul>
  <li>We do not know if there is a number that will solve this pattern.
    <ul>
      <li>There is an infinite amount of inputs, and we don’t know which one will run the code infinitely.</li>
    </ul>
  </li>
</ul>

<h2 id="vocab">
<a class="anchor" href="#vocab" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vocab</h2>

<h3 id="collatz-conjecture">
<a class="anchor" href="#collatz-conjecture" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collatz Conjecture</h3>
<ul>
  <li>one of the most famous unsolved problems in mathematics.
    <ul>
      <li>it asks whether repeating two simple arithmetic operations will eventually transform every positive integer into 1.</li>
    </ul>
  </li>
</ul>

<h3 id="hailstone-numbers">
<a class="anchor" href="#hailstone-numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hailstone numbers</h3>
<ul>
  <li>The sequence of integers generated by Collatz conjecture
    <ul>
      <li>Examples: Input : N = 7 Output : Hailstone Numbers: 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 No.</li>
      <li>Code terminates at 1.</li>
    </ul>
  </li>
</ul>

<h3 id="undecidable-problems">
<a class="anchor" href="#undecidable-problems" aria-hidden="true"><span class="octicon octicon-link"></span></a>Undecidable problems</h3>
<ul>
  <li>A Problem that should give a “yes” or “no” answer, but yet no algorithm exists that can answer correctly on all inputs.</li>
</ul>

<h3 id="iteration">
<a class="anchor" href="#iteration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iteration</h3>
<ul>
  <li>The action or a process of iterating or repeating:
    <ul>
      <li>such as. : a procedure in which repetition of a sequence of operations yields results successively closer to a desired result.</li>
    </ul>
  </li>
</ul>

<h2 id="hailstone-numbers-code-example">
<a class="anchor" href="#hailstone-numbers-code-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hailstone Numbers Code Example</h2>

<p><img src="/ominicient-lavebear/images/yasha2.png" alt="" title="https://github.com/LiavB2/ominicient-lavebear"></p>

<h2 id="algorithm-efficiency">
<a class="anchor" href="#algorithm-efficiency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Algorithm Efficiency</h2>
<ul>
  <li>Inefficient algorthims are slower and could sometimes take more processing and computing power to run</li>
</ul>

<h1 id="hacks">
<a class="anchor" href="#hacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hacks</h1>

<h2 id="combine-hailstone-and-number-of-iterations">
<a class="anchor" href="#combine-hailstone-and-number-of-iterations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Combine Hailstone and Number of Iterations</h2>
<ul>
  <li>Here is an efficient code for the Collatz conjecture that combined the number of iteraions and the Hailstone numbers:</li>
</ul>

<p><img src="/ominicient-lavebear/images/yasha4.png" alt="" title="https://github.com/LiavB2/ominicient-lavebear"></p>

<h2 id="write-one-algorithm-that-is-efficient-and-one-that-is-inefficient-compare-them-and-explain-why-one-is-and-why-one-isnt-efficient">
<a class="anchor" href="#write-one-algorithm-that-is-efficient-and-one-that-is-inefficient-compare-them-and-explain-why-one-is-and-why-one-isnt-efficient" aria-hidden="true"><span class="octicon octicon-link"></span></a>Write one algorithm that is efficient and one that is inefficient. Compare them and explain why one is and why one isn’t efficient.</h2>

<p><img src="/ominicient-lavebear/images/yasha5.png" alt="" title="https://github.com/LiavB2/ominicient-lavebear"></p>

<ul>
  <li>As you can see, I have coded 2 algorithms that find the factorial of 8.
    <ul>
      <li>The first one is clearly way more efficient since I used the import math library and used the factorial function to find the factorial of 8. On the other hand, the second one manually multiplies 8<em>7</em>6<em>5</em>4<em>3</em>2*1 which is clearly way less efficient and more clunky</li>
      <li>The first algorithm is not only easier to read and faster to code, it runs much faster (only 0.1 secs) while the less efficient algorithm took 8 times longer (.8 seconds) to run.</li>
      <li>Furthermore the first algorithm is certainly less efficent than the first because of its easier readability and faster runtime.</li>
    </ul>
  </li>
</ul>

<h2 id="how-one-algorithm-can-be-more-efficient-than-annother-using-mathematical-and-formal-reasoning">
<a class="anchor" href="#how-one-algorithm-can-be-more-efficient-than-annother-using-mathematical-and-formal-reasoning" aria-hidden="true"><span class="octicon octicon-link"></span></a>How one algorithm can be more efficient than annother using mathematical and formal reasoning</h2>
<ul>
  <li>There are several factors that can contribute to the efficiency of an algorithm. One of the main factors is the time complexity of the algorithm, which is a measure of how long the algorithm takes to run as a function of the size of the input.
    <ul>
      <li>An algorithm with a lower time complexity will generally be more efficient than an algorithm with a higher time complexity, because it will take less time to complete for large inputs.</li>
    </ul>
  </li>
  <li>The amount of memory that the running of an algorithm uses up is another factor in determining the efficiency of it. Algorithms that use more processing and memory power to run are generally less efficient, especially if there is another algorithm that uses less memory and processing power to achieve the same task.</li>
</ul>

<h2 id="use-variables-if-statements-and-loops-to-program-an-algorithm">
<a class="anchor" href="#use-variables-if-statements-and-loops-to-program-an-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Use variables, if statements, and loops to program an algorithm</h2>

<p><img src="/ominicient-lavebear/images/amay1.png" alt="" title="https://github.com/LiavB2/ominicient-lavebear"></p>

<ul>
  <li>This algorithm that I coded tells you whether you should go outside or not based on the inputted temperature outside.</li>
</ul>

  </div><a class="u-url" href="/ominicient-lavebear/student%20lessons/2022/12/14/3.17-3.18.html" hidden></a>
</article>
